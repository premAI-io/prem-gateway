package main

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/strslice"
	"github.com/docker/docker/client"
	log "github.com/sirupsen/logrus"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

const (
	letsEncryptStaging = "https://acme-staging-v02.api.letsencrypt.org/directory"
	letsEncryptProd    = "https://acme-v02.api.letsencrypt.org/directory"

	premappService = "premapp"
	premdService   = "premd"
)

var (
	letEncryptProd bool
)

type DnsInfo struct {
	Domain    string `json:"domain"`
	SubDomain string `json:"sub_domain"`
	NodeName  string `json:"node_name"`
	Email     string `json:"email"`
}

func main() {
	serviceNames := os.Getenv("SERVICES")
	services := make([]string, 0)
	if serviceNames != "" {
		services = append(services, strings.Split(serviceNames, ",")...)
	}
	services = append(services, "dnsd")

	letsEncrypt := os.Getenv("LETSENCRYPT_PROD")
	if letsEncrypt != "" {
		letEncryptProd = true
	}

	http.HandleFunc("/domain-provisioned", func(w http.ResponseWriter, r *http.Request) {
		go func() {
			if r.Method != http.MethodPost {
				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
				return
			}

			email := r.URL.Query().Get("email")
			domain := r.URL.Query().Get("domain")

			premServices := getPremServicesForRestart(services)
			if len(premServices) > 0 {
				if err := restartServicesWithTls(domain, nil, premServices); err != nil {
					log.Error("Error restarting containers from domainProvisioned : ", err)
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}
			}

			if err := restartServicesWithTls(domain, services, nil); err != nil {
				log.Error("Error restarting containers from domainProvisioned : ", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			//TODO maybe add health check to all restarted services since services
			//needs to be restarted before traefik can pick up the new labels
			time.Sleep(time.Second * 3)

			if err := restartTraefikWithTls(email); err != nil {
				log.Error("Error restarting traefik from domain-provisioned : ", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}()

		if _, err := io.WriteString(w, "OK"); err != nil {
			return
		}
	})

	// TODO expose domainUpdated/Deleted endpoints to restart services without TLS
	//think how to fetch AI running services

	go func() {
		log.Info("Starting checking if dns exists")
		for {
			if _, err := http.Get("http://traefik:8080/ping"); err != nil {
				log.Error("Error pinging Traefik: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			if _, err := http.Get("http://dnsd:8080/dns/check"); err != nil {
				log.Error("Error checking DNSd: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			resp, err := http.Get("http://dnsd:8080/dns/existing")
			if err != nil {
				log.Info("Error getting existing DNS: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			if resp.StatusCode != 200 {
				log.Error("Got non-200 status code: ", resp.StatusCode)
				resp.Body.Close()
				time.Sleep(time.Second * 5)
				continue
			}

			body, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				log.Error("Error reading body: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			var dnsInfo DnsInfo
			if err := json.Unmarshal(body, &dnsInfo); err != nil {
				log.Error("Error unmarshaling DNS info: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			if dnsInfo.Domain == "" || dnsInfo.Email == "" {
				log.Info("Domain or email is empty, skipping restart")
				break
			}

			if err := restartServicesWithTls(dnsInfo.Domain, services, nil); err != nil {
				log.Error("Error restarting containers: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			//TODO maybe add health check to all restarted services since services
			//needs to be restarted before traefik can pick up the new labels
			time.Sleep(time.Second * 3)

			if err := restartTraefikWithTls(dnsInfo.Email); err != nil {
				log.Error("Error restarting traefik: ", err)
				time.Sleep(time.Second * 5)
				continue
			}

			log.Info("Containers restarted")
			break
		}
		log.Info("Finished checking if dns exists")
	}()

	log.Info("Starting controller daemon on port 8080")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		log.Errorf("Controller daemon failed to start: %v", err)
	}
}

func getPremServicesForRestart(srvcs []string) map[string]int {
	svcs := make(map[string]int)
	if contains(srvcs, premdService) {
		resp, err := http.Get("http://premd:8000/v1/services/")
		if err != nil {
			return nil
		}

		if resp == nil {
			return nil
		}

		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			return nil
		}

		var premServices []PremService
		if err := json.NewDecoder(resp.Body).Decode(&premServices); err != nil {
			return nil
		}

		for _, v := range premServices {
			if v.Running {
				svcs[v.Id] = v.RunningPort
			}
		}
	}

	return svcs
}

func contains(slice []string, str string) bool {
	for _, a := range slice {
		if a == str {
			return true
		}
	}
	return false
}

func restartContainer(
	ctx context.Context,
	cli *client.Client,
	containerName string,
	labels map[string]string,
	cmds strslice.StrSlice,
) error {
	containerJson, err := cli.ContainerInspect(ctx, containerName)
	if err != nil {
		return err
	}
	newConfig := containerJson.Config
	//TODO check duplicate labels and cmds
	if len(labels) > 0 {
		newLabels := make(map[string]string)
		for k, v := range newConfig.Labels {
			if !strings.Contains(k, "traefik") {
				newLabels[k] = v
			}
		}
		for k, v := range labels {
			newLabels[k] = v
		}
		newConfig.Labels = newLabels
	}
	if len(cmds) > 0 {
		newConfig.Cmd = append(newConfig.Cmd, cmds...)
	}

	noWaitTimeout := 0
	if err := cli.ContainerStop(
		ctx, containerName, container.StopOptions{Timeout: &noWaitTimeout},
	); err != nil {
		return err
	}
	if err := cli.ContainerRemove(
		ctx, containerName, types.ContainerRemoveOptions{},
	); err != nil {
		//TODO this is workaround for restarting prem services, container removal
		//fails because prem-services are started with --rm flag in prem-daemon
		//and we can't remove them, so we just ignore the error
		//TODO maybe we should check if the container is prem-service and if it is
		//then we should just restart it without removing it
		//sleeping for 5 seconds to wait until container is removed
		log.Warning("Error removing container: ", err)
		time.Sleep(time.Second * 5)
		//return err
	}

	if _, err := cli.ContainerCreate(
		ctx,
		newConfig,
		containerJson.HostConfig,
		&network.NetworkingConfig{
			EndpointsConfig: containerJson.NetworkSettings.Networks,
		},
		nil,
		containerName,
	); err != nil {
		log.Error("Error creating container: ", err)
		return err
	}

	if err := cli.ContainerStart(
		ctx, containerName, types.ContainerStartOptions{},
	); err != nil {
		log.Error("Error starting container: ", err)
		return err
	}

	return nil
}

func restartServicesWithTls(domain string, services []string, premServices map[string]int) error {
	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("failed to create docker client: %v", err)
	}

	for _, v := range services {
		switch v {
		case premappService:
			basicAuthMiddlewareLabelKey, basicAuthMiddlewareLabelValue, basicAuthName, err := getPremServiceBasicAuthInfo(ctx, cli)
			if err != nil {
				return err
			}

			// TODO handle restart of prem-gateway with dns exists

			labels := map[string]string{
				"traefik.enable":                                               "true",
				"traefik.http.routers.premapp-http.rule":                       fmt.Sprintf("PathPrefix(`/`) && Host(`%s`)", domain),
				"traefik.http.routers.premapp-http.entrypoints":                "web",
				"traefik.http.routers.premapp-https.rule":                      fmt.Sprintf("PathPrefix(`/`) && Host(`%s`)", domain),
				"traefik.http.routers.premapp-https.entrypoints":               "websecure",
				"traefik.http.routers.premapp-https.tls.certresolver":          "myresolver",
				"traefik.http.middlewares.http-to-https.redirectscheme.scheme": "https",
				"traefik.http.routers.premapp-http.middlewares":                fmt.Sprintf("http-to-https, %s", basicAuthName),
				"traefik.http.routers.premapp-https.middlewares":               basicAuthName,
				"traefik.http.services.premapp.loadbalancer.server.port":       "8080",
				basicAuthMiddlewareLabelKey:                                    basicAuthMiddlewareLabelValue,
			}

			if err := restartContainer(ctx, cli, v, labels, nil); err != nil {
				return fmt.Errorf("failed to restart container %s: %v", v, err)
			}
		default:
			labels := map[string]string{
				"traefik.enable": "true",
				fmt.Sprintf("traefik.http.routers.%s.rule", v):             fmt.Sprintf("PathPrefix(`/`) && Host(`%s.%s`)", v, domain),
				fmt.Sprintf("traefik.http.routers.%s.entrypoints", v):      "websecure",
				fmt.Sprintf("traefik.http.routers.%s.tls.certresolver", v): "myresolver",
			}

			if err := restartContainer(ctx, cli, v, labels, nil); err != nil {
				return fmt.Errorf("failed to restart container %s: %v", v, err)
			}
		}

		log.Infof("Restarted container %s\n", v)
	}

	for k, v := range premServices {
		labels := map[string]string{
			"traefik.enable": "true",
			fmt.Sprintf("traefik.http.routers.%s-http.rule", k):                    fmt.Sprintf("Host(`%s.%s`)", k, domain),
			fmt.Sprintf("traefik.http.routers.%s-http.entrypoints", k):             "web",
			fmt.Sprintf("traefik.http.routers.%s-https.rule", k):                   fmt.Sprintf("Host(`%s.%s`)", k, domain),
			fmt.Sprintf("traefik.http.routers.%s-https.entrypoints", k):            "websecure",
			fmt.Sprintf("traefik.http.routers.%s-%s.tls.certresolver", k, "https"): "myresolver",
			"traefik.http.middlewares.http-to-https.redirectscheme.scheme":         "https",
			fmt.Sprintf("traefik.http.routers.%s-http.middlewares", k):             "http-to-https",
			fmt.Sprintf("traefik.http.services.%s.loadbalancer.server.port", k):    strconv.Itoa(v),
		}

		if err := restartContainer(ctx, cli, k, labels, nil); err != nil {
			return fmt.Errorf("failed to restart container %s: %v", k, err)
		}

		log.Infof("Restarted container %s\n", k)
	}

	return nil
}

func restartTraefikWithTls(email string) error {
	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("failed to create docker client: %v", err)
	}

	traefikLetsEncryptUrl := letsEncryptProd
	if !letEncryptProd {
		traefikLetsEncryptUrl = letsEncryptStaging
	}

	cmds := strslice.StrSlice{
		"--providers.docker=true",
		"--providers.docker.exposedbydefault=false",
		"--accesslog=true",
		"--ping",
		"--entrypoints.web.address=:80",
		"--certificatesresolvers.myresolver.acme.email=" + email,
		"--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json",
		"--certificatesresolvers.myresolver.acme.tlschallenge=true",
		"--certificatesresolvers.myresolver.acme.caserver=" + traefikLetsEncryptUrl,
		"--entrypoints.websecure.address=:443",
	}

	if err := restartContainer(ctx, cli, "traefik", nil, cmds); err != nil {
		return fmt.Errorf("failed to restart container traefik: %v", err)
	}

	log.Info("Restarted container traefik")

	return nil
}

type PremService struct {
	Id            string `json:"id"`
	Name          string `json:"name"`
	Beta          bool   `json:"beta"`
	Description   string `json:"description"`
	Documentation string `json:"documentation"`
	Icon          string `json:"icon"`
	ModelInfo     struct {
		MemoryRequirements int `json:"memoryRequirements"`
		TokensPerSecond    int `json:"tokensPerSecond"`
	} `json:"modelInfo"`
	Interfaces   []string `json:"interfaces"`
	DockerImages struct {
		Gpu struct {
			Size  int64  `json:"size"`
			Image string `json:"image"`
		} `json:"gpu"`
	} `json:"dockerImages"`
	DefaultPort         int    `json:"defaultPort"`
	DefaultExternalPort int    `json:"defaultExternalPort"`
	RunningPort         int    `json:"runningPort"`
	Banner              string `json:"banner"`
	Running             bool   `json:"running"`
	Downloaded          bool   `json:"downloaded"`
	EnoughMemory        bool   `json:"enoughMemory"`
	EnoughSystemMemory  bool   `json:"enoughSystemMemory"`
	EnoughStorage       bool   `json:"enoughStorage"`
	Command             string `json:"command"`
	DockerImage         string `json:"dockerImage"`
	DockerImageSize     int    `json:"dockerImageSize"`
	Supported           bool   `json:"supported"`
	InvokeMethod        struct {
		Header string `json:"header"`
		SendTo string `json:"baseUrl"`
	} `json:"invokeMethod"`
}

func getPremServiceBasicAuthInfo(
	ctx context.Context, cli *client.Client,
) (string, string, string, error) {
	var (
		basicAuthMiddlewareLabelKey   string
		basicAuthMiddlewareLabelValue string
		basicAuthName                 string
	)

	containerJson, err := cli.ContainerInspect(ctx, premappService)
	if err != nil {
		return "", "", "", fmt.Errorf("failed to inspect container %s: %v", premappService, err)
	}

	for k, v := range containerJson.Config.Labels {
		if strings.Contains(k, "basicauth") {
			basicAuthMiddlewareLabelKey = k
			basicAuthMiddlewareLabelValue = v

			parts := strings.Split(k, ".")
			for i, part := range parts {
				if part == "middlewares" && i+1 < len(parts) {
					basicAuthName = parts[i+1]
					break
				}
			}

			return basicAuthMiddlewareLabelKey, basicAuthMiddlewareLabelValue, basicAuthName, nil
		}
	}

	return "", "", "", nil
}
